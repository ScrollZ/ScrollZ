/*
 * ircII: a new irc client.  I like it.  I hope you will too!
 *
 * Written By Michael Sandrof
 * 
 * Copyright (c) 1990 Michael Sandrof.
 * Copyright (c) 1991, 1992 Troy Rollo.
 * Copyright (c) 1992-1998 Matthew R. Green.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $Id: irc.c,v 1.14 1999-03-02 18:00:32 f Exp $
 */

#define IRCII_VERSION	"4.4F"

/*
 * INTERNAL_VERSION is the number that the special alias $V returns.
 * Make sure you are prepared for floods, pestilence, hordes of locusts, 
 * and all sorts of HELL to break loose if you change this number.
 * Its format is actually YYYYMMDD, for the _release_ date of the
 * client..
 */
/**************************** PATCHED by Flier ******************************/
/*#define INTERNAL_VERSION	"19970414"*/
#define INTERNAL_VERSION	"19980302"
/****************************************************************************/

#include "irc.h"

#include <sys/stat.h>
#ifndef __MSDOS__
#include <pwd.h>
#endif /* __MSDOS__ */

#ifdef ISC22
# include <sys/bsdtypes.h>
#endif /* ISC22 */

#ifdef ESIX
# include <lan/net_types.h>
#endif /* ESIX */

/**************************** PATCHED by Flier ******************************
#ifdef DO_USER2
# include <setjmp.h>
#endif
****************************************************************************/

#include "status.h"
#include "dcc.h"
#include "names.h"
#include "vars.h"
#include "input.h"
#include "alias.h"
#include "output.h"
#include "ircterm.h"
#include "exec.h"
#include "screen.h"
#include "log.h"
#include "server.h"
#include "hook.h"
#include "keys.h"
#include "ircaux.h"
#include "edit.h"
#include "window.h"
#include "history.h"
#include "exec.h"
#include "notify.h"
#include "mail.h"
#include "debug.h"
#include "newio.h"
#include "ctcp.h"

/************************ PATCHED by Flier **************************/
#include "myvars.h"

#ifdef SZ32
#undef IRCPATH
#define IRCPATH "."
#endif
/****************************************************************************/

int	irc_port = IRC_PORT,			/* port of ircd */
	send_text_flag = -1,			/* used in the send_text()
						 * routine */
	use_flow_control = USE_FLOW_CONTROL,	/* true: ^Q/^S used for flow
						 * cntl */
	irc_io_loop = 1,			/* see irc_io below */
	break_io_processing = 0,		/* more forceful than
						 * irc_io_loop */
	current_numeric,			/* this is negative of the
						 * current numeric! */
	dumb = 0,				/* if true, IRCII is put in
						 * "dumb" mode */
	no_fork = 0,				/* if true, IRCII won't with
						 * -b or -e */
	use_input = 1,				/* if 0, stdin is never
						 * checked */
	waiting = 0,				/* used by /WAIT command */
	who_mask = 0;				/* keeps track of which /who
						 * switchs are set */

char	*zero	= "0";
char	*one	= "1";

char	oper_command = 0;	/* true just after an oper() command is
				 * given.  Used to tell the difference
				 * between an incorrect password generated by
				 * an oper() command and one generated when
				 * connecting to a new server */

char    *ScrollZver="uH 6[G8294K:gy54q+l.a3Tv9ljV0f0WVrKnhjgFKV9?";

char	global_all_off[2];		/* lame kludge to get around lameness */
char	FAR MyHostName[80];	       	/* The local machine name. Used by
					 * DCC TALK */
	struct	in_addr	MyHostAddr;	/* The local machine address */
extern	char	*last_away_nick;

char	*invite_channel = (char *) 0,	/* last channel of an INVITE */
	FAR buffer[BIG_BUFFER_SIZE + 1],/* multipurpose buffer */
	*ircrc_file = (char *) 0,	/* full path .ircrc file */
	*my_path = (char *) 0,		/* path to users home dir */
	*irc_path = (char *) 0,		/* paths used by /load */
	*irc_lib = (char *) 0,		/* path to the ircII library */
 	*nickname = (char *) 0,		/* users nickname */
	FAR hostname[NAME_LEN + 1],    	/* name of current host */
	FAR realname[REALNAME_LEN + 1],	/* real name of user */
	FAR username[NAME_LEN + 1],    	/* usernameof user */
	*send_umode = NULL,		/* sent umode */
	*args_str = (char *) 0,		/* list of command line args */
	*last_notify_nick = (char *) 0,	/* last detected nickname */
	empty_string[] = "",		/* just an empty string */
	*who_name = (char *) 0,		/* extra /who switch info */
	*who_file = (char *) 0,		/* extra /who switch info */
	*who_server = (char *) 0,	/* extra /who switch info */
	*who_host = (char *) 0,		/* extra /who switch info */
	*who_nick = (char *) 0,		/* extra /who switch info */
	*who_real = (char *) 0,		/* extra /who switch info */
	*cannot_open = (char *) 0,	/* extra /who switch info */
	*cut_buffer = (char *) 0;	/* global cut_buffer */
#ifdef IPCHECKING
char    *channel_join = (char *) 0;     /* channel we are joining */
#endif

	int away_set = 0;		/* set if there is an away
					 * message anywhere */
	int	qflag;			/* set if we ignore .ircrc */
	int	bflag;			/* set if we load .ircrc before connecting */
	time_t	idle_time = 0;
        time_t  start_time;

static	RETSIGTYPE	cntl_c _((void));
static	RETSIGTYPE	sig_user1 _((void)) ;
/**************************** PATCHED by Flier ******************************/
/*#ifdef	DO_USER2
static	RETSIGTYPE	sig_user2 _((void)) ;
#endif*/
static	RETSIGTYPE	sig_user2 _((void)) ;
/****************************************************************************/
#ifdef	MUNIX
static	RETSIGTYPE	cntl_y _((void));
#endif
#ifdef CORECATCH
static	RETSIGTYPE	coredump _((void)) ;
#endif /* CORECATCH */
/**************************** PATCHED by Flier ******************************/
/*static	time_t		TimerTimeout _((void));*/
#if defined(HAVETIMEOFDAY) && defined(BETTERTIMER)
static struct timeval TimerTimeout _((void));
#else
static time_t TimerTimeout _((void));
#endif
/****************************************************************************/
static	void	quit_response _((char *, char *));
static	void	show_version _((void));
static	char	*get_arg _((char *, char *, int *));
static	char	*parse_args _((char **, int));

static	int	cntl_c_hit = 0;

/**************************** PATCHED by Flier ******************************
#ifdef DO_USER2
	jmp_buf	outta_here;
#endif
****************************************************************************/

	char	irc_version[] = IRCII_VERSION;
	char	internal_version[] = INTERNAL_VERSION;

static	char	FAR switch_help[] =
"Usage: irc [switches] [nickname] [server list] \n\
  The [server list] is a whitespace separate list of server name\n\
  The [switches] may be any or all of the following\n\
   -c <channel>\tjoins <channel> o startup\n\
   -p <port>\tdefault server connection port (usually 6667)\n\
   -f\t\tyour terminal uses flow controls (^S/^Q), so IRCII shouldn't\n\
   -F\t\tyour terminal doesn't use flow control (default)\n\
   -H <hostname>\tuse the following host for virtual hosting\n\
   -C <name>\tused to cloak process as name\n\
   -s\t\tdon't use separate server processes (ircio)\n\
   -S\t\tuse separate server processes (ircio)\n\
   -d\t\truns IRCII in \"dumb\" terminal mode\n\
   -q\t\tdoes not load .scrollzrc\n\
   -a\t\tadds default servers and command line servers to server list\n\
   -b\t\tload .scrollzrc before connecting to a server\n";

static	char	FAR switch_help_l[] =
#ifdef COMMAND_LINE_L
"   -l <file>\tloads <file> in place of your .scrollzrc\n\
   -L <file>\tloads <file> in place of your .scrollzrc and expands $ expandos\n";
#else
"";
#endif

/**************************** PATCHED by Flier ******************************/
extern void Logo _((char *, char *, char *));
extern void CheckTimeMinute _((void));
extern void CheckCdccTimers _((void));
extern void InitVars _((void));
extern void Reset _((char *, char *, char *));
extern void SwitchNick _((void));
extern void CleanUp _((void));

#ifdef WANTANSI
char *Colors[NUMCOLORS]={
 /*  off  */
 "\033[0m" ,
 /*  bold       underline  flash      reverse */
 "\033[1m" , "\033[4m"  , "\033[5m"  , "\033[7m"  ,
 /*  black      red        green      yellow     blue          */
 "\033[30m", "\033[31m" , "\033[32m" , "\033[33m" , "\033[34m" ,
 /*  purple     cyan       white      blackbg    redbg         */
 "\033[35m", "\033[36m" , "\033[37m" , "\033[40m" , "\033[41m" ,
 /*  greenbg    yellowbg   bluebg     purplebg   cyanbg        */
 "\033[42m", "\033[43m" , "\033[44m" , "\033[45m" , "\033[46m" ,
 /*  whitebg    nobold                                         */
 "\033[47m", "\033[22m"
};
#endif

struct friends *frlist;
struct autobankicks *abklist;
struct words *wordlist;
struct wholeftstr *wholist;
struct splitstr *splitlist,*splitlist1;
#ifdef ACID
struct list *nickwatchlist,*tmpnickwatch;
#endif
struct spingstr *spinglist;
struct encrstr *encrlist;
char  defban;
char  bold=2;
char  *DefaultServer=(char *) 0;
char  *ScrollZstr=(char *) 0;
char  *ScrollZlame="ircII 4.4F+ScrollZ v1.8i4 (2.3.99)+Cdcc v1.8";
char  *ScrollZlame1=(char *) 0;
#ifdef EXTRA_STUFF
char  *EString=(char *) 0;
#endif
char  *DefaultSignOff=(char *) 0;
char  *DefaultSetAway=(char *) 0;
char  *DefaultSetBack=(char *) 0;
char  *DefaultUserinfo=(char *) 0;
char  *DefaultFinger=(char *) 0;
char  *AutoJoinChannels=(char *) 0;
char  *CdccUlDir=(char *) 0;
char  *CdccDlDir=(char *) 0;
char  *WhoKilled=(char *) 0;
char  *CdccChannels=(char *) 0;
char  *AutoRejoinChannels=(char *) 0;
char  *MDopWatchChannels=(char *) 0;
char  *ShowFakesChannels=(char *) 0;
char  *KickOnFloodChannels=(char *) 0;
char  *KickWatchChannels=(char *) 0;
char  *NHProtChannels=(char *) 0;
char  *NickWatchChannels=(char *) 0;
char  *ShowAwayChannels=(char *) 0;
char  *KickOpsChannels=(char *) 0;
char  *KickOnBanChannels=(char *) 0;
char  *BitchChannels=(char *) 0;
char  *FriendListChannels=(char *) 0;
#ifdef EXTRAS
char  *IdleKickChannels=(char *) 0;
char  *SignoffChannels=(char *) 0;
#endif
char  *CompressModesChannels=(char *) 0;
char  *StampChannels=(char *) 0;
char  *EncryptPassword=(char *) 0;
char  *StatsFilter=(char *) 0;
char  *AutoReplyBuffer=(char *) 0;
char  *OrigNick=(char *) 0;
/****** Coded by Zakath ******/
/* patched by acidflash */
#ifdef ACID
char *AcidVersion="AcidMods v2.0";
#endif
char  *VirtualHost=(char *) 0;
char  *HelpPathVar=(char *) 0;
char  *CelerityNtfy=(char *) 0;
struct in_addr VirtualAddr;
struct urlstr *urllist;
int   AwayMsgNum=0;
int   CdccPackNum=0;
int   CdccSendNum=0;
int   CdccRecvNum=0;
#if defined(EXTRAS) || defined(FLIER)
int   AutoInv;
#endif
#ifdef CELE
int   SentAway=0;
#endif
char  *URLBuffer=(char *) 0;
/*******************************/
char  *CurrentNick=(char *) 0;
char  *LastChat=(char *) 0;
char  *CurrentDCC=(char *) 0;
char  *DefaultK=(char *) 0;
char  *DefaultBK=(char *) 0;
char  *DefaultBKI=(char *) 0;
char  *DefaultBKT=(char *) 0;
char  *DefaultFK=(char *) 0;
char  *DefaultLK=(char *) 0;
char  *DefaultABK=(char *) 0;
char  *DefaultSK=(char *) 0;
#ifdef ACID
char  *DefaultKill=(char *) 0;
#endif
char  *PermUserMode=(char *) 0;
char  *AutoReplyString=(char *) 0;
int   DeopPrinted;
int   KickPrinted;
int   NickPrinted;
int   usersloaded;
int   unban;
int   inFlierWI;
int   inFlierWho;
int   inFlierNotify;
int   inFlierLinks;
int   inFlierFKill;
int   inFlierNickCompl;
int   inFlierTrace;
int   ExtMes;
int   NHProt;
int   NHDisp;
int   AutoGet;
int   DeopSensor;
int   KickSensor;
int   NickSensor;
int   AutoAwayTime;
int   NickWatch;
int   MDopWatch;
int   KickWatch;
int   MDopTimer;
int   KickTimer;
int   NickTimer;
int   IgnoreTime;
int   ShitIgnoreTime;
int   AutoRejoin;
int   AutoJoinOnInv;
int   FloodProt;
int   FloodMessages;
int   FloodSeconds;
int   CdccIdle;
int   CdccLimit;
int   CdccQueueLimit;
#ifdef EXTRA_STUFF
int   RenameFiles;
#endif
int   Security;
int   ServerNotice;
int   CTCPCloaking;
int   ShowFakes;
int   ShowAway;
int   AutoOpDelay;
#if defined(HAVETIMEOFDAY) && defined(CELE)
struct timeval LagTimer;
#else
int   LagTimer;
#endif
int   KickOps;
int   KickOnFlood;
int   KickOnBan;
#ifdef SCKICKS
int   NumberOfScatterKicks;
#endif
#ifndef CELE
int   NumberOfSignOffMsgs;
#endif
int   ShowNick;
int   PlistTime;
int   NlistTime;
int   LinksNumber;
int   AwaySaveSet;
int   ShowWallop;
int   LongStatus;
double BytesReceived;
double BytesSent;
int   FriendList;
int   OrigNickChange;
int   IRCQuit;
int   NotifyMode;
int   URLCatch;
int   Ego;
int   LogOn;
int   ShowDCCStatus;
int   DCCDone;
int   AutoNickCompl;
int   CdccStats;
#if defined(OPERVISION) && defined(WANTANSI)
int   OperV;
#endif
int   Bitch;
#ifdef EXTRAS
int   IdleKick;
int   IdleTime;
int   ShowSignoffChan;
#endif
int   CompressModes;
#ifdef WANTANSI
int   DisplaymIRC;
#endif
int   DCCWarning;
int   CdccOverWrite;
int   OrigNickDelay;
int   Stamp;
int   CdccVerbose;
time_t LastCheck;
time_t LastPlist;
time_t LastNlist;
time_t LastServer;
time_t LastNick;
time_t LastLinks;
#if defined(HAVETIMEOFDAY) && defined(CELE)
struct timeval PingSent;
#else
time_t PingSent=0;
#endif
/****** Coded by Zakath ******/
char VersionInfo[] = {
#ifdef WANTANSI
    'A',
#else
    'a',
#endif
#ifdef EXTRAS
    'E',
#else
    'e',
#endif
#ifdef NEWCSCAN
    'C',
#else
    'c',
#endif
#if defined(HAVETIMEOFDAY) && defined(BETTERTIMER)
    'T',
#else
    't',
#endif
#ifdef SCKICKS
    'S',
#else
    's',
#endif
#if defined(NON_BLOCKING_CONNECTS) && defined(HYPERDCC)
    'D',
#else
    'd',
#endif
#ifdef CTCPPAGE
    'P',
#else
    'p',
#endif
#ifdef COUNTRY
    'Y',
#else
    'y',
#endif
#if defined(OPERVISION) && defined(WANTANSI)
    ' ',
    'O',
    'V',
#endif
#ifdef CELE
    ' ',
    'c',
    'y',
#endif
    ' ',
#ifdef GENX
    'G',
#else
    'g',
#endif
#ifdef ACID
    'I',
#else
    'i',
#endif
#ifdef VILAS
    'V',
#else
    'v',
#endif
#ifdef JIMMIE
    'J',
#else
    'j',
#endif
#ifdef TDF
    'X',
#else
    'x',
#endif
    '\0'};
/*****************************/
struct NickList *nickcompl=NULL;
struct NickList *tabnickcompl=NULL;
#ifdef WANTANSI
struct colorstr CmdsColors[NUMCMDCOLORS];
#endif
/****************************************************************************/

/* irc_exit: cleans up and leaves */
RETSIGTYPE
/**************************** PATCHED by Flier ******************************/
irc_exit(quit)
/****************************************************************************/
{
	do_hook(EXIT_LIST, "Exiting");
	close_server(-1, "Leaving");
	logger(0);
	set_history_file((char *) 0);
#ifndef _Windows
	clean_up_processes();
#endif /* _Windows */
	if (!dumb)
	{
		cursor_to_input();	/* Needed so that ircII doesn't gobble
					 * the last line of the kill. */
		term_cr();
		if (term_clear_to_eol())
			term_space_erase(0);
		term_reset();
#ifdef ESIX
		endwin();		/* Added for curses */
		system("tput reset");
		new_stty("sane");
#endif /* ESIX */
/**************************** PATCHED by Flier ******************************/
#ifdef SZNCURSES
                endwin();
#endif /* SZNCURSES */
/****************************************************************************/
	}
/**************************** PATCHED by Flier ******************************/
        /*exit(0);*/
        CleanUp();
#ifdef _Windows
   DestroyWindow(hwndMain);
#else
        exit(quit);
#endif /* _Windows */
/****************************************************************************/
}

#ifdef CORECATCH
/* sigsegv: something to handle segfaults in a nice way */
/* this needs to be changed to *NOT* use printf(). */
RETSIGTYPE
coredump(sig)
	int	sig;
{
	printf("IRCII has been terminated by a SIG%s\n\r", signals[sig]);
	printf("Please inform the ircii bugs list (ircii-bugs@eterna.com.au) of this\n\r");
	printf("with as much detail as possible about what you were doing when it happened.\n\r");
	printf("Please include the version of IRCII (%s) and type of system in the report.\n\r", irc_version);
	fflush(stdout);
/**************************** PATCHED by Flier ******************************/
        /*irc_exit();*/
        irc_exit(0);
/****************************************************************************/
}
#endif

/*
 * quit_response: Used by irc_io when called from irc_quit to see if we got
 * the right response to our question.  If the response was affirmative, the
 * user gets booted from irc.  Otherwise, life goes on. 
 */
static	void
quit_response(dummy, ptr)
	char	*dummy;
	char	*ptr;
{
 	size_t	len;
 	int	old_irc_io_loop;

	old_irc_io_loop = irc_io_loop;
	irc_io_loop = 0;
	if ((len = strlen(ptr)) != 0)
	{
		if (!my_strnicmp(ptr, "yes", len))
		{
			send_to_server("QUIT");
/**************************** PATCHED by Flier ******************************/
                        /*irc_exit();*/
                        irc_exit(0);
/****************************************************************************/
		}
	}
	irc_io_loop = old_irc_io_loop;
}

/* irc_quit: prompts the user if they wish to exit, then does the right thing */
void
irc_quit(key, ptr)
	u_int	key;
	char *	ptr;
{
	static	int in_it = 0;

	if (in_it)
		return;
	in_it = 1;
	add_wait_prompt("Do you really want to quit? ", quit_response,
		empty_string, WAIT_PROMPT_LINE);
	in_it = 0;
}

/*
 * cntl_c: emergency exit.... if somehow everything else freezes up, hitting
 * ^C five times should kill the program. 
 */
static	RETSIGTYPE
cntl_c()
{
#ifdef SYSVSIGNALS
	(void) MY_SIGNAL(SIGINT, (sigfunc *) cntl_c, 0);
#endif /* SYSVSIGNALS */
	if (cntl_c_hit++ >= 4)
/**************************** PATCHED by Flier ******************************/
		/*irc_exit();*/
		irc_exit(152);
/****************************************************************************/
}

static RETSIGTYPE
sig_user1()
{
#ifdef SYSVSIGNALS
	(void) sigfunc *(SIGUSR1, (sigfunc *) sig_user1, 0);
#endif /* SYSVSIGNALS */
	say("Got SIGUSR1, closing DCC connections and EXECed processes");
	close_all_dcc();
#ifndef _Windows
	close_all_exec();
#endif /* _Windows */
}

/**************************** PATCHED by Flier ******************************
#ifdef DO_USER2
****************************************************************************/
static RETSIGTYPE
sig_user2()
{
#ifdef SYSVSIGNALS
	(void) MY_SIGNAL(SIGUSR2, (sigfunc *) sig_user2, 0);
#endif /* SYSVSIGNALS */
/**************************** PATCHED by Flier ******************************/
	/*say("Got SIGUSR2, jumping to normal loop");
	longjmp(outta_here);*/
 	say("Got SIGUSR2, reloading ScrollZ.save");
 	Reset(NULL,NULL,NULL);
/****************************************************************************/
}
/**************************** PATCHED by Flier ******************************
#endif 
****************************************************************************/

#ifdef MUNIX
/* A characteristic of PCS MUNIX - Ctrl-Y produces a SIGQUIT */
static RETSIGTYPE
cntl_y()
{
	(void) MY_SIGNAL(SIGQUIT, (sigfunc *) cntl_y, 0);
	edit_char(25); /* Ctrl-Y */
}
#endif

/* shows the version of irc */
static	void
show_version()
{
	printf("ircII version %s (%s)\n\r", irc_version, internal_version);
	exit (0);
}

/* get_arg: used by parse_args() to get an argument after a switch */
static	char	*
get_arg(arg, next, ac)
	char	*arg;
	char	*next;
	int	*ac;
{
	(*ac)++;
	if (*arg)
		return (arg);
	else
	{
		if (next)
			return (next);
		fprintf(stderr, "irc: missing parameter\n");
                exit(1);
 		return (0); /* cleans up a warning */
	}
}

/*
 * parse_args: parse command line arguments for irc, and sets all initial
 * flags, etc. 
 */
static	char	*
parse_args(argv, argc)
	char	**argv;
	int	argc;
{
	char	*arg,
		*ptr;
	int	ac;
	int	add_servers = 0;
	char	*channel = (char *) NULL;
	struct	passwd	*entry;
	struct	hostent	*hp;
	int	minus_minus = 0;
/**************************** PATCHED by Flier ******************************/
        char    *CloakCommand=(char *) 0;
/****************************************************************************/

    /*
     * Note that this uses the global buffer to build the args_str list,
     * which is a whitespace separated list of the arguments used when
     * loading the .ircrc and GLOBAL_IRCRC files.
     */
	*realname = '\0';
	ac = 1;
	strmcpy(buffer, argv[0], BIG_BUFFER_SIZE);
	strmcat(buffer, " ", BIG_BUFFER_SIZE);
/**************************** PATCHED by Flier ******************************/
/* Patched by Zakath */
/* Moved here by Flier so we can override environment variable with -H */
	if ((ptr=getenv("IRCHOST"))) malloc_strcpy(&VirtualHost,ptr);
        /* for Da_P */
        if ((ptr=getenv("VIRTIP"))) malloc_strcpy(&VirtualHost,ptr);
/* ***************** */
/****************************************************************************/
	while ((arg = argv[ac++]) != (char *) NULL)
	{
		strmcat(buffer, argv[ac-1], BIG_BUFFER_SIZE);
		strmcat(buffer, " ", BIG_BUFFER_SIZE);
		if ((*arg == '-') != '\0')
		{
			++arg;
			while (*arg)
			{
				switch (*(arg++))
				{
/**************************** PATCHED by Flier ******************************/
				case 'C':
                                        malloc_strcpy(&CloakCommand,get_arg(arg,argv[ac],&ac));
					break;
/* Patched by Zakath */
				case 'H':
                                        malloc_strcpy(&VirtualHost,get_arg(arg,argv[ac],&ac));
					break;
/* ***************** */
/****************************************************************************/
				case 'v':
					show_version();
					break;
				case 'b':
					if (qflag)
					{
						fprintf(stderr, "Can not use -b with -q\n");
						exit(1);
					}
					bflag = 1;
					break;
				case 'c':
					malloc_strcpy(&channel, get_arg(arg,
							argv[ac], &ac));
					break;
				case 'p':
					irc_port = atoi(get_arg(arg, argv[ac],
							&ac));
					break;
				case 'f':
					use_flow_control = 1;
					break;
				case 'F':
					use_flow_control = 0;
					break;
				case 'd':
					dumb = 1;
					break;
#ifdef DEBUG
				case 'D':
					setdlevel(atoi(get_arg(arg, argv[ac],
						&ac)));
					break;
				case 'o':
					{
						FILE	*fp;
						char	*file = get_arg(arg, argv[ac], &ac);

						if (!file)
						{
							printf("irc: need filename for -o\n");
							exit(-1);
						}
						fp = freopen(file, "w", stderr);
						if (!fp)
						{
							printf("irc: can not open %s: %s\n", file, errno ? "" : strerror(errno));
							exit(-1);
						}
					}
#endif /* DEBUG */
#ifdef COMMAND_LINE_L
				case 'l':
					malloc_strcpy(&ircrc_file, get_arg(arg,
							argv[ac], &ac));
					break;
				case 'L':
					malloc_strcpy(&ircrc_file, get_arg(arg,
							argv[ac], &ac));
					malloc_strcat(&ircrc_file," -");
					break;
#endif /* COMMAND_LINE_L */
				case 'a':
					add_servers = 1;
					break;
				case 's':
					using_server_process = 0;
					break;
				case 'S':
					using_server_process = 1;
					break;
				case 'q':
					if (bflag)
					{
						fprintf(stderr, "Can not use -q with -b\n");
						exit(1);
					}
					qflag = 1;
					break;
				case '-':
					if (argv[ac])
					{
						while ((arg = argv[ac++]) != NULL)
						{
							strmcat(command_line, arg, BIG_BUFFER_SIZE);
							strmcat(command_line, " ", BIG_BUFFER_SIZE);
						}
						command_line[strlen(command_line)-1] = '\0';
					}
					minus_minus = 1;
					break;
				default:
					fprintf(stderr, "%s%s", switch_help, switch_help_l);
					exit(1);
				}
			}
		}
		else
		{
 			if (nickname && *nickname)
				build_server_list(arg);
			else
 				malloc_strcpy(&nickname, arg);
		}
		if (minus_minus)
			break;
	}
	malloc_strcpy(&args_str, buffer);
/**************************** PATCHED by Flier ******************************/
/* Patched by Zakath */
	if ((ptr=getenv("IRCHELP"))) malloc_strcpy(&HelpPathVar,ptr);
/* ***************** */
/****************************************************************************/
	if ((char *) 0 != (ptr = (char *) getenv("IRCLIB")))
	{
		malloc_strcpy(&irc_lib, ptr);
		malloc_strcat(&irc_lib, "/");
	}
	else
		malloc_strcpy(&irc_lib, IRCLIB);

	if ((char *) 0 == ircrc_file && (char *) 0 != (ptr = getenv("IRCRC")))
		malloc_strcpy(&ircrc_file, ptr);

 	if ((nickname == 0 || *nickname == '\0') && (char *) 0 != (ptr = getenv("IRCNICK")))
 		malloc_strcpy(&nickname, ptr);

	if ((char *) 0 != (ptr = getenv("IRCUMODE")))
		malloc_strcpy(&send_umode, ptr);

	if ((char *) 0 != (ptr = getenv("IRCNAME")))
		strmcpy(realname, ptr, REALNAME_LEN);

	if ((char *) 0 != (ptr = getenv("IRCPATH")))
		malloc_strcpy(&irc_path, ptr);
	else
	{
#ifdef IRCPATH
		malloc_strcpy(&irc_path, IRCPATH);
#else
#ifdef __MSDOS__
		malloc_strcpy(&irc_path, ".:~/irc:");
#else
		malloc_strcpy(&irc_path, ".:~/.irc:");
#endif /* __MSDOS__ */
		malloc_strcat(&irc_path, irc_lib);
		malloc_strcat(&irc_path, "script");
#endif
	}

	set_string_var(LOAD_PATH_VAR, irc_path);
	new_free(&irc_path);
	if ((char *) 0 != (ptr = getenv("IRCSERVER")))
		build_server_list(ptr);
	if (0 == number_of_servers || add_servers)
	{
#ifdef SERVERS_FILE
		if (read_server_file() || (number_of_servers == 0))
#endif
		{
 			char *s = (char *) 0;

#ifdef _Windows
			GetProfileString("IRC", "Server",
						"Choose.File->Setup.From.Menu",
						buffer, sizeof(buffer));
 			malloc_strcpy(&s, buffer);
#else
 			malloc_strcpy(&s, DEFAULT_SERVER);
#endif /* _Windows */
 			build_server_list(s);
 			new_free(&s);
		}
	}
#ifdef _Windows
 	if (nickname == 0 || !*nickname)
 	{
 		GetProfileString("IRC", "Nick", "ircuser", buffer, BIG_BUFFER_SIZE);
 		malloc_strcpy(&nickname, buffer);
 	}
	GetProfileString("IRC", "UserName", "ircuser", username, NAME_LEN + 1);
	GetProfileString("IRC", "RealName", "ircuser", realname, REALNAME_LEN + 1);
	GetProfileString("IRC", "StartDir", get_path(4), buffer, BIG_BUFFER_SIZE);
	malloc_strcpy(&my_path, buffer);
#else /* _Windows */
	if ((struct passwd *) 0 != (entry = getpwuid(getuid())))
	{
		if ((*realname == '\0') && entry->pw_gecos && *(entry->pw_gecos))
		{
#ifdef GECOS_DELIMITER
			if ((ptr = index(entry->pw_gecos, GECOS_DELIMITER)) 
					!= NULL)
				*ptr = '\0';
#endif /* GECOS_DELIMITER */
			if ((ptr = strchr(entry->pw_gecos, '&')) == NULL)
				strmcpy(realname, entry->pw_gecos, REALNAME_LEN);
			else {
 				size_t len = ptr - entry->pw_gecos;

				if (len < REALNAME_LEN && *(entry->pw_name)) {
					char *q = realname + len;

					strmcpy(realname, entry->pw_gecos, len);
					strmcat(realname, entry->pw_name, REALNAME_LEN);
					strmcat(realname, ptr + 1, REALNAME_LEN);
					if (islower(*q) && (q == realname || isspace(*(q - 1))))
						*q = toupper(*q);
				} else
					strmcpy(realname, entry->pw_gecos, REALNAME_LEN);
			}
		}
		if (entry->pw_name && *(entry->pw_name))
			strmcpy(username, entry->pw_name, NAME_LEN);

		if (entry->pw_dir && *(entry->pw_dir))
			malloc_strcpy(&my_path, entry->pw_dir);
	}
#endif /* _Windows */
	if ((char *) 0 != (ptr = getenv("HOME")))
		malloc_strcpy(&my_path, ptr);
	else if (*my_path == '\0')
		malloc_strcpy(&my_path, "/");

	if ('\0' == *realname)
		strmcpy(realname, "*Unknown*", REALNAME_LEN);

	if ('\0' == *username)
	{
		if ((ptr = getenv("USER")) != NULL)
			strmcpy(username, ptr, NAME_LEN);
		else
			strmcpy(username, "Unknown", NAME_LEN);
	}
/**************************** PATCHED by Flier ******************************/
	if ((char *) 0 != (ptr = getenv("IRCUSER")))
		strmcpy(username, ptr, NAME_LEN);
/****************************************************************************/
	gethostname(MyHostName, sizeof(MyHostName));
	if ((hp = gethostbyname(MyHostName)) != NULL)
		bcopy(hp->h_addr, (char *) &MyHostAddr, sizeof(MyHostAddr));
 	if (nickname == 0 || *nickname == '\0')
 		malloc_strcpy(&nickname, username);
#if 0 /* blundernet changed this */
	if (0 == check_nickname(nickname))
	{
		fprintf(stderr, "Illegal nickname %s\n", nickname);
		exit(1);
	}
#endif
	if ((char *) 0 == ircrc_file)
	{
		ircrc_file = (char *) new_malloc(strlen(my_path) +
			strlen(IRCRC_NAME) + 1);
		strcpy(ircrc_file, my_path);
		strcat(ircrc_file, IRCRC_NAME);
	}
/**************************** PATCHED by Flier ******************************/
        if (CloakCommand) {
            for (ac=argc-1;ac>=0;ac--) memset(argv[ac],0,strlen(argv[ac]));
            strcpy(argv[0],CloakCommand);
            new_free(&CloakCommand);
        }
/****************************************************************************/
        return (channel);
}

/*
 * TimerTimeout:  Called from irc_io to help create the timeout
 * part of the call to select.
 */
/**************************** PATCHED by Flier ******************************/
/*static time_t*/
#if defined(HAVETIMEOFDAY) && defined(BETTERTIMER)
static struct timeval
#else
static time_t
#endif
/****************************************************************************/
TimerTimeout()
{
/**************************** PATCHED by Flier ******************************/
	/*time_t	current;
	time_t	timeout_in;*/
        time_t  nickt=LastNick+OrigNickDelay;
#if defined(HAVETIMEOFDAY) && defined(BETTERTIMER)
        struct  timeval current,largest;
#else
        time_t	current,largest;
        time_t  timeout_in;
#endif

	/*if (!PendingTimers)
		return 70;*/ /* Just larger than the maximum of 60 */
	/*time(&current);
	timeout_in = PendingTimers->time - current;
	return (timeout_in < 0) ? 0 : timeout_in;*/
#if defined(HAVETIMEOFDAY) && defined(BETTERTIMER)
        gettimeofday(&current,NULL);
        /* If ORIGNICK is off set nickt to current+75 to prevent
           excessive CPU usage (meaning we actually ignore this
           event, see below) */
        if (!(OrigNickChange && OrigNick)) nickt=current.tv_sec+75;
        if (!PendingTimers) {
            /* Just larger than the maximum of 60 */
            current.tv_sec=
                nickt-current.tv_sec>70?70:nickt-current.tv_sec;
            current.tv_usec=0;
            return(current);
        }
        if (PendingTimers->time.tv_sec>nickt) {
            largest.tv_sec=nickt;
            largest.tv_usec=0;
        }
        else {
            largest.tv_sec=PendingTimers->time.tv_sec;
            largest.tv_usec=PendingTimers->time.tv_usec;
        }
        current.tv_sec=largest.tv_sec-current.tv_sec;
        if (current.tv_usec<=largest.tv_usec)
            current.tv_usec=largest.tv_usec-current.tv_usec;
        else {
            current.tv_usec=largest.tv_usec-current.tv_usec+1000000;
            current.tv_sec--;
        }
        if (current.tv_sec<0 || current.tv_usec<0) {
            current.tv_sec=0;
            current.tv_usec=0;
        }
        return(current);
#else
        time(&current);
        /* If ORIGNICK is off set nickt to current+75 to prevent
           excessive CPU usage (meaning we actually ignore this
           event, see below) */
        if (!(OrigNickChange && OrigNick)) nickt=current+75;
        if (!PendingTimers)
            /* Just larger than the maximum of 60 */
            return(nickt-current>70?70:nickt-current);
        largest=PendingTimers->time>nickt?nickt:PendingTimers->time;
        timeout_in=largest-current;
	return((timeout_in<0)?0:timeout_in);
#endif
/****************************************************************************/
}

/*
 * irc_io: the main irc input/output loop.   Handles all io from keyboard,
 * server, exec'd processes, etc.  If a prompt is specified, it is displayed
 * in the input line and cannot be backspaced over, etc. The func is a
 * function which will take the place of the SEND_LINE function (which is
 * what happens when you hit return at the end of a line). This function must
 * decide if it's ok to exit based on anything you really want.  It can then
 * set the global irc_io_loop to false to cause irc_io to exit. 
 */
int
irc_io(prompt, func, my_use_input, loop)
	char	*prompt;
 	void	(*func) _((u_int, char *));
	int	my_use_input;
	int	loop;
{
	static	int	level = 0;
	fd_set	rd,
		wd;
 	char	lbuf[BIG_BUFFER_SIZE + 1];	/* buffer much bigger than
						 * IRCD_BUFFER_SIZE */
	struct	timeval cursor_timeout,
		clock_timeout,
		right_away,
		timer,
		*timeptr;
	int	hold_over;
	int	old_loop;
	char	*last_input = NULL;
	char	*last_prompt = NULL;
 	void	(*last_func) _((u_int, char *));
	int	one_key = 0;
	Screen	*screen,
		*old_current_screen;

	last_func = get_send_line();
 	if (my_use_input == -1)
		one_key = 1, prompt = NULL;
#ifdef	PRIV_PORT_ULC
	seteuid(getuid());
#endif
	/* time before cursor jumps from display area to input line */
	cursor_timeout.tv_usec = 0L;
	cursor_timeout.tv_sec = 1L;

	/* time delay for updating of internal clock */
	clock_timeout.tv_usec = 0L;
	clock_timeout.tv_sec = 30L;

	right_away.tv_usec = 0L;
	right_away.tv_sec = 0L;

	timer.tv_usec = 0L;

	old_loop = irc_io_loop;
	irc_io_loop = loop;

			/*
	if (level++ > 20)
			 * irc_io has been recursive to date.
			 * with multiple xterms and screen
			 * windows, this has to change
			 */
	if (level++ > 5)
	{
		level--;
		irc_io_loop = old_loop;
		return (1);
	}
	if (!dumb)
	{
		if (my_use_input)
		{
			malloc_strcpy(&last_input, get_input());
			set_input(empty_string);
			last_func = get_send_line();
			change_send_line(func);
		}
		if (prompt)
		{
			malloc_strcpy(&last_prompt, get_input_prompt());
			set_input_prompt(prompt);
		}
	}
	/*
	 * Here we work out if this has been called recursively or
	 * not..  and if not so.. -phone
	 */

/**************************** PATCHED by Flier ******************************/
/*#if defined(DEBUG) || defined(DO_USER2)
	if (level != 1)
	{
#ifdef DEBUG
		yell("--- Recursive call to irc_io() - careful");
#endif
	}
	else
	{
#ifdef DO_USER2
		if (setjmp(outta_here))
			yell("*** Got SIGUSR2, Aborting");
#endif
	}
#endif*/
#if defined(DEBUG)
	if (level != 1)
            yell("--- Recursive call to irc_io() - careful");
#endif
/****************************************************************************/

	timeptr = &clock_timeout;
	do
	{
		break_io_processing = 0;
 		sed = 0;
                FD_ZERO(&rd);
		FD_ZERO(&wd);
		set_process_bits(&rd);
		set_server_bits(&rd, &wd);
#ifndef _Windows
		if (my_use_input)
			for (screen = screen_list;screen; screen = screen->next)
				if (screen->alive)
					FD_SET(screen->fdin, &rd);
		set_dcc_bits(&rd, &wd);
		if (term_reset_flag)
		{
			refresh_screen(0, (char *) 0);
			term_reset_flag = 0;
		}
#endif /* _Windows */
/**************************** PATCHED by Flier ******************************/
		/*timer.tv_sec = TimerTimeout();
		if (timer.tv_sec <= timeptr->tv_sec)
			timeptr = &timer;*/
#if defined(HAVETIMEOFDAY) && defined(BETTERTIMER)
                timer=TimerTimeout();
                if ((float) (timer.tv_sec+timer.tv_usec/1000000.0)<=
                    (float) (timeptr->tv_sec+timeptr->tv_usec/1000000.0))
			timeptr = &timer;
#else
                timer.tv_sec = TimerTimeout();
		if (timer.tv_sec <= timeptr->tv_sec)
			timeptr = &timer;
#endif
/****************************************************************************/
		if ((hold_over = unhold_windows()) != 0)
			timeptr = &right_away;
		Debug((7, "irc_io: selecting with %l:%l timeout", timeptr->tv_sec,
			timeptr->tv_usec));
		switch (new_select(&rd, &wd, timeptr))
		{
		case 0:
		case -1:
	/*
	 * yay for the QNX socket manager... drift here, drift there, oops,
	 * i fell down a hole..
	 */
#ifdef __QNX__
			if (errno == EBADF || errno == ESRCH)
				irc_io_loop = 0;
#endif
			if (cntl_c_hit)
			{
				if (one_key)
				{
					irc_io_loop = 0;
					break;
				}
 				edit_char((u_int)'\003');
				cntl_c_hit = 0;
			}
			if (!hold_over)
				cursor_to_input();
			break;
		default:
#ifndef _Windows
			if (term_reset_flag)
			{
				refresh_screen(0, (char *) 0);
				term_reset_flag = 0;
			}
#endif /* _Windows */
			old_current_screen = current_screen;
			set_current_screen(last_input_screen);
			if (!break_io_processing)
				dcc_check(&rd, &wd);
			if (!break_io_processing)
				do_server(&rd, &wd);
			set_current_screen(old_current_screen);
			for (screen = screen_list; screen &&
				!break_io_processing; screen = screen->next)
			{
				if (!screen->alive)
					continue;
				set_current_screen(screen);
				if (FD_ISSET(screen->fdin, &rd))
				{

	/*
	 * This section of code handles all in put from the terminal(s).
	 * connected to ircII.  Perhaps the idle time *shouldn't* be 
	 * reset unless its not a screen-fd that was closed..
	 *
	 * This section indented - phone, jan 1993
	 */

			idle_time = time(0);
			if (dumb)
			{
				int     old_timeout;

				old_timeout = dgets_timeout(1);
/**************************** PATCHED by Flier ******************************/
 				/*if (dgets(lbuf, INPUT_BUFFER_SIZE,
						screen->fdin, (char *) 0))*/
				if (dgets(lbuf, INPUT_BUFFER_SIZE,
						screen->fdin, (char *) 0, 0))
/****************************************************************************/
				{
					(void) dgets_timeout(old_timeout);
					if (one_key)
					{
						irc_io_loop = 0;
						break;
					}
 					*(lbuf + strlen(lbuf) - 1) = '\0';
					if (get_int_var(INPUT_ALIASES_VAR))	
 						parse_line(NULL, lbuf,
						    empty_string, 1, 0);
					else
 						parse_line(NULL, lbuf,
						    NULL, 1, 0);
				}
				else
				{
					say("IRCII exiting on EOF from stdin");
/**************************** PATCHED by Flier ******************************/
                                        /*irc_exit();*/
                                        irc_exit(0);
/****************************************************************************/
				}
			}
			else
			{
				int server;
				char	loc_buffer[BIG_BUFFER_SIZE + 1];
				int	n, i;

				server = from_server;
				from_server = get_window_server(0);
				last_input_screen = screen;
				if (one_key)
				{
/**************************** PATCHED by Flier ******************************/
					/*if (read(screen->fdin, buffer, 1))*/
#ifdef SZNCURSES
 					if (term_read(buffer,1))
#else
 					if (read(screen->fdin, lbuf, 1))
#endif /* SZNCURSES */
/****************************************************************************/
					{
						irc_io_loop = 0;
						break;
					}
				/*
				 * Following Fizzy's remark below, if we 
				 * don't use window create, we can't kill
				 * then, can we?  --FlashMan, October 1994
				 */
#ifdef WINDOW_CREATE
					else
					{
#ifndef _Windows
						if (!is_main_screen(screen))
							kill_screen(screen);
						else
#endif /* _Windows */
/**************************** PATCHED by Flier ******************************/
							/*irc_exit();*/
							irc_exit(0);
/****************************************************************************/
					}
#endif /* WINDOW_CREATE */
				}
/**************************** PATCHED by Flier ******************************/
				/*else if ((n = read(screen->fdin, loc_buffer,
						BIG_BUFFER_SIZE)) != 0)*/
#ifdef SZNCURSES
 				else if ((n=term_read(loc_buffer,BIG_BUFFER_SIZE))!=0)
#else
				else if ((n = read(screen->fdin, loc_buffer,
					      BIG_BUFFER_SIZE)) != 0)
#endif /* SZNCURSES */
/****************************************************************************/
					for (i = 0; i < n; i++)
 						edit_char((u_int)loc_buffer[i]);
		/*
		 * if the current screen isn't the main  screen,
		 * then the socket to the current screen must have
		 * closed, so we call kill_screen() to handle 
		 * this - phone, jan 1993.
		 * but not when we arent running windows - Fizzy, may 1993
		 * if it is the main screen we got an EOF on, we exit..
		 * closed tty -> chew cpu -> bad .. -phone, july 1993.
		 */
#ifdef WINDOW_CREATE
				else
				{
					if (!is_main_screen(screen))
						kill_screen(screen);
					else
/**************************** PATCHED by Flier ******************************/
						/*irc_exit();*/
						irc_exit(0);
/****************************************************************************/
				}
#endif /* WINDOW_CREATE */
				cntl_c_hit = 0;
				from_server = server;
			}

		/* End of intendation */

				}
			}
			set_current_screen(old_current_screen);
#ifndef _Windows
			if (!break_io_processing)
				do_processes(&rd);
#endif /* _Windows */
			break;
		}
		execute_timer();
#ifndef _Windows
		check_process_limits();
		(void) check_wait_status(-1);
#endif /* _Windows */
		if ((primary_server == -1) && !never_connected)
			do_hook(DISCONNECT_LIST, "%s", nickname);
		timeptr = &clock_timeout;

		old_current_screen = current_screen;
		for (current_screen = screen_list; current_screen;
				current_screen = current_screen->next)
			if (current_screen->alive && is_cursor_in_display())
				timeptr = &cursor_timeout;
		set_current_screen(old_current_screen);

		if (update_clock(0))
		{
			if (get_int_var(CLOCK_VAR) || check_mail_status())
			{
				status_update(1);
				cursor_to_input();
			}
			if (primary_server != -1)
				do_notify();
/**************************** PATCHED by Flier ******************************/
                        CheckTimeMinute();
                        CheckCdccTimers();
#if defined(HAVETIMEOFDAY) && defined(CELE)
                        gettimeofday(&PingSent,NULL);
                        if (from_server!=-1 && PingSent.tv_sec-start_time>30)
#else
                        PingSent=time((time_t *) 0);
                        if (from_server!=-1 && PingSent-start_time>30)
#endif
                            send_to_server("PING :%s",get_server_nickname(from_server));
/****************************************************************************/
		}
/**************************** PATCHED by Flier ******************************/
                if (OrigNickChange && OrigNick) SwitchNick();
/****************************************************************************/
	}
	while (irc_io_loop);
	level--;
	irc_io_loop = old_loop;
	if (! dumb)
	{
		if (my_use_input)
		{
			set_input(last_input);
			new_free(&last_input);
			change_send_line(last_func);
		}
		if (prompt)
		{
			if (level == 0)
			    set_input_prompt(get_string_var(INPUT_PROMPT_VAR));
			else
			    set_input_prompt(last_prompt);
			new_free(&last_prompt);
		}
	}
	update_input(UPDATE_ALL);
	return (0);
}

int
#ifdef _Windows
old_main(int argc, char **argv)
#else
/*ARGSUSED*/
main _((int, char *[], char *[]));

int main(argc, argv, envp)
	int	argc;
	char	*argv[];
	char	*envp[];
#endif /* _Windows */
{
	char	*channel;

#ifdef _Windows
	reset_pointers();
#endif /* _Windows */
	start_time = time((time_t *)0);
#ifdef	SOCKS
	SOCKSinit(argv[0]);
#endif /* SOCKS */
	channel = parse_args(argv, argc);
#if defined(ESIX)
	/* Curses code added for ESIX use */
	if (!dumb)
	{
		initscr();
		noecho();
		cbreak();
	}
#endif /* ESIX */
#ifndef _Windows
	if ((use_input == 0) && !no_fork)
	{
		if (fork())
			_exit(0);
	}
#endif /* _Windows */
#if defined(ESIX) || defined(_Windows)
	if (gethostname(hostname, NAME_LEN) == NULL)
#else
	if (gethostname(hostname, NAME_LEN))
#endif /* ESIX */
	{
#ifdef _Windows
		switch(WSAGetLastError())
        {
          case WSAEFAULT:
      		MessageBox(0, "Couldn't get host name", 0, MB_OK);
            break;
          case WSANOTINITIALISED:
      		MessageBox(0, "Couldn't get host name", 0, MB_OK);
            break;
          case WSAENETDOWN:
      		MessageBox(0, "Couldn't get host name", 0, MB_OK);
            break;
          case WSAEINPROGRESS:
      		MessageBox(0, "Couldn't get host name", 0, MB_OK);
            break;
          default:
            break;
        }

#else
		fprintf(stderr, "irc: couldn't figure out the name of your machine!\n");
		exit(1);
#endif /* _Windows */
	}
/**************************** PATCHED by Flier ******************************/
        printf("Process [%d] connected to tty [%s]\n",getpid(),ttyname(0));
/****************************************************************************/
	if (dumb)
		new_window();
	else
	{
		init_screen();
#ifndef _Windows
/**************************** PATCHED by Flier ******************************/
/* Patch for OS/2 EMX */
/*#if !defined(MUNIX) && !defined(_RT) && !defined(ESIX)*/
#if !defined(MUNIX) && !defined(_RT) && !defined(ESIX) && !defined(__EMX__)
/****************************************************************************/
		(void) MY_SIGNAL(SIGCONT, (sigfunc *) term_cont, 0);
#endif /* !defined(MUNIX) && !defined(_RT) && !defined(ESIX) */
#if !defined(_RT) && defined(SIGWINCH)
		(void) MY_SIGNAL(SIGWINCH, (sigfunc *) sig_refresh_screen, 0);
#endif /* _RT */
#ifndef ALLOC_DEBUG
# ifdef CORECATCH
		(void) MY_SIGNAL(SIGSEGV, (sigfunc *) coredump, 0);
#  ifdef SIGBUS
		(void) MY_SIGNAL(SIGBUS, (sigfunc *) coredump, 0);
#  endif
# else
		(void) MY_SIGNAL(SIGSEGV, (sigfunc *) SIG_DFL, 0);
		/* Linux doesn't have SIGBUS */
#  ifdef SIGBUS
		(void) MY_SIGNAL(SIGBUS, (sigfunc *) SIG_DFL, 0);
#  endif /* SIGBUS */
# endif /* CORECATCH */
#endif /* ALLOC_DEBUG */
#ifdef MUNIX
		(void) MY_SIGNAL(SIGQUIT, (sigfunc *) cntl_y, 0);
#endif
		(void) MY_SIGNAL(SIGHUP, (sigfunc *) irc_exit, 0);
		(void) MY_SIGNAL(SIGTERM, (sigfunc *) irc_exit, 0);
		(void) MY_SIGNAL(SIGPIPE, (sigfunc *) SIG_IGN, 0);
		(void) MY_SIGNAL(SIGINT, (sigfunc *) cntl_c, 0);
#ifdef SIGSTOP
		(void) MY_SIGNAL(SIGSTOP, (sigfunc *) SIG_IGN, 0);
#endif
		(void) MY_SIGNAL(SIGUSR1, (sigfunc *) sig_user1, 0);
/**************************** PATCHED by Flier ******************************/
/*#ifdef DO_USER2*/
/****************************************************************************/
		(void) MY_SIGNAL(SIGUSR2, (sigfunc *) sig_user2, 0);
/**************************** PATCHED by Flier ******************************/
/*#endif*/
/****************************************************************************/
#endif /* _Windows */
	}

/**************************** Patched by Flier ******************************/
        InitVars();
/****************************************************************************/
	init_variables();

	if (!dumb)
	{
		build_status((char *) 0);
		update_input(UPDATE_ALL);
	}

#ifdef MOTD_FILE
	{
		struct	stat	motd_stat,
				my_stat;
		char	*motd = NULL;
		int	des;

		malloc_strcpy(&motd, irc_lib);
		malloc_strcat(&motd, MOTD_FILE);
		if (stat_file(motd, &motd_stat) == 0)
		{
			strmcpy(buffer, my_path, BIG_BUFFER_SIZE);
#ifdef __MSDOS__
			strmcat(buffer, "/ircmotd.red", BIG_BUFFER_SIZE);
#else
			strmcat(buffer, "/.ircmotd", BIG_BUFFER_SIZE);
#endif /* __MSDOS__ */
			if (stat_file(buffer, &my_stat))
			{
				my_stat.st_atime = 0L;
				my_stat.st_mtime = 0L;
			}
			unlink(buffer);
			if ((des = open(buffer, O_CREAT, S_IREAD | S_IWRITE))
					!= -1)
				new_close(des);
			if (motd_stat.st_mtime > my_stat.st_mtime)
			{
				put_file(motd);
		/* Thanks to Mark Dame <mdame@uceng.ec.edu> for this one */

#if defined(PAUSE_AFTER_MOTD) && PAUSE_AFTER_MOTD
		input_pause("********  Press any key to continue  ********");
#endif
				clear_window_by_refnum(0);
			}
		}
		new_free(&motd);
	}
#endif /* MOTD_FILE */

/**************************** Patched by Flier ******************************/
        Logo(NULL,NULL,NULL);
/****************************************************************************/
	global_all_off[0] = ALL_OFF;
	global_all_off[1] = '\0';
	if (bflag)
		load_ircrc();
        get_connected(0, 0);
	/* set_window_server(0, primary_server, 0); */
	/* Already done in get_connected() -Sol */
        if (channel)
	{
		char    *ptr;
 
		ptr = strtok(channel, ",");
		if (is_channel(ptr))
			add_channel(ptr, 0, CHAN_LIMBO, (ChannelList *) 0);
		while ((ptr = strtok(NULL,",")) != NULL)
			if (is_channel(ptr))
				add_channel(ptr, 0, CHAN_LIMBO, (ChannelList *) 0);
		new_free(&channel);
	}
	idle_time = time(0);
	set_input(empty_string);
#ifndef _Windows
	irc_io(get_string_var(INPUT_PROMPT_VAR), NULL, use_input, irc_io_loop);
/**************************** PATCHED by Flier ******************************/
        /*irc_exit();*/
        irc_exit(0);
/****************************************************************************/
#endif /* _Windows */
 	return 0;
}
